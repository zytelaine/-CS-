几个概念的正式定义是这样的：

属性（attribute）： 数据库中的字段，即数据库中表的列。
超键（super key）： 在关系中能**唯⼀标识元组**的属性**集**称为关系模式的超键
候选键（candidate key）： **不含有多余属性**的超键称为候选键
主键（primary key）： ⽤户选**作元组标识**的⼀个**候选键**称为主键
主属性： **候选键中**的属性称为主属性。
非主属性： 不属于任何候选键的属性称为非主属性。
外键（foreign key）： 在一个表中存在的另一个表的主键称为此表的外键。

原文链接：https://blog.csdn.net/weixin_43954951/article/details/125494783



## BCNF范式

### 1. BCNF的核心定义

一个关系模式R属于BCNF，当且仅当对于**每一个非平凡的函数依赖**X→Y（其中Y不是X的子集），满足以下条件之一：

- X是R的一个**超键**（即X能唯一确定整个元组）
- 或者该依赖是**平凡的**（即Y⊆X）

换句话说：**每个决定因素都必须是候选键**。

**超键可以包含多余属性，但是绝对不能失去最小超键（候选键）的任何一个属性**

比如：

{用户ID，产品ID}：候选键（最小不可拆） →可以做X

{用户ID，产品ID，订单ID（冗余），数量（冗余）}：超键→可做X

{用户ID，订单ID，数量}：非超键（拆开了候选键，无法标识关系中所有元组）→不可做X

#### *BCNF不允许任何非超键决定其他属性！！！*

### 2. BCNF与3NF的关系

- **BCNF比3NF更严格**：所有BCNF的关系都自动满足3NF，但满足3NF的关系不一定满足BCNF
- **关键区别**：
  - 3NF允许：**非主属性传递依赖于候选键**
  - BCNF禁止：任何属性（包括主属性）对非超键的依赖

### 3. 判断BCNF的实用方法

对于关系模式R和函数依赖集F：

1. 找出R的所有候选键
2. 检查F中的每个函数依赖X→Y：
   - 如果X不是超键且Y-X≠∅（非平凡依赖）
   - 则R不属于BCNF

### 4.BCNF分解方法

关系不满足BCNF时，可以通过以下步骤分解：

1. 找到一个违反BCNF的函数依赖X→Y
2. 将R分解为：
   - **R1 = X∪Y**
   - **R2 = R-Y**
3. 对R1和R2递归应用此过程，直到所有关系都满足BCNF

### 5. 经典示例分析

例1：**关系模式**：R(学生, 课程, 教师)
**函数依赖**：

- {学生, 课程} → 教师
- 教师 → 课程

**问题**：

- 候选键：{学生, 课程}
- 教师→课程违反BCNF（教师不是超键）

**BCNF分解**：

1. R1(教师, 课程) [来自教师→课程]
2. R2(学生, 教师) [剩余属性，通过教师关联]



1. 例2：**关系模式**：
   R(订单ID,产品ID,客户ID,数量,折扣)

2. **函数依赖**：

3. 1. {订单ID,产品ID}→{数量,折扣}
      （候选键：`{订单ID, 产品ID}`）
   2. 订单ID→客户ID
      （`订单ID` 不是超键，违反BCNF）

4. **分解步骤**：

5. 1. **找到违反BCNF的依赖**：订单ID→客户ID

   2. **分解**：

      - R1(订单ID,客户ID)
      - R2(订单ID,产品ID,数量,折扣)

      

6. ## 3NF与BCNF的区别

7. ### **1. 定义对比**

8. ### **(1) 3NF的定义**

9. 一个关系模式 R*R* 属于 **3NF**，当且仅当对于每一个 **非平凡的函数依赖** X→Y*X*→*Y*（即 Y*Y* 不是 X*X* 的子集），满足以下条件之一：

   **X是超键**（即 X*X* 能唯一标识整个元组），**或**

   **Y是主属性**（即 Y*Y* **属于**某个候选键）。

10. 换句话说，3NF允许 **非主属性** 完全依赖于候选键，但不允许 **非主属性** 传递依赖于候选键（即不能有 A→B→C*A*→*B*→*C*，其中 C*C* 是非主属性）。

11. ### **(2) BCNF的定义**

12. 一个关系模式 R*R* 属于 **BCNF**，当且仅当对于每一个 **非平凡的函数依赖** X→Y*X*→*Y*，满足：

13. 1. **X\*X\* 必须是超键**（即 X*X* 能唯一标识整个元组）。

14. 换句话说，**BCNF不允许任何非超键决定其他属性**，即使是主属性也不行。

15. ------

16. ### **2. 关键区别**

17. | **对比项**                           | **3NF**                             | **BCNF**                     |
    | :----------------------------------- | :---------------------------------- | :--------------------------- |
    | **决定因素（X→Y\*X\*→\*Y\*）的要求** | X*X* 可以是超键，或者 Y*Y* 是主属性 | X*X* 必须是超键              |
    | **允许的冗余程度**                   | 允许部分冗余（如主属性间的依赖）    | 冗余更少                     |
    | **规范化严格性**                     | 较宽松                              | 更严格                       |
    | **是否允许传递依赖**                 | 允许主属性间的传递依赖              | 不允许任何非超键决定其他属性 |

18. ------

19. ### **3. 示例分析**

20. ### **示例1（满足3NF但不满足BCNF）**

21. **关系模式**：`学生选课(学号, 课程, 教师)`
    **函数依赖**：

22. 1. `{学号, 课程} → 教师`（候选键是 `{学号, 课程}`）
    2. `教师 → 课程`（教师决定课程）

23. **分析**：

24. - **3NF**：满足，因为 `教师 → 课程` 的 `课程` 是主属性（属于候选键）。
    - **BCNF**：不满足，因为 `教师` 不是超键（`教师` 不能单独决定整个元组）。

25. **问题**：

26. - 如果一个教师教多门课，会导致数据冗余（如教师A教数学和物理，`课程` 信息会重复）。
    - **BCNF分解**：
      - `R1(教师, 课程)`（来自 `教师 → 课程`）
      - `R2(学号, 教师)`（剩余属性）

## 良好的关系特征

无损分解

## 函数依赖理论

### 1.依赖集的闭包

### 2.Armstrong公式

### 3.属性集的闭包

### 4.正则覆盖

### 5.无损分解

### 6.保持依赖

## 分解算法

### 1. BCNF（上面已有）

### 2. 3NF分解

